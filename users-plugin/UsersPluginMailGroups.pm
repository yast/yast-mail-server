#! /usr/bin/perl -w
#
# Example of plugin module
# This is the API part of UsersPluginMailGroups plugin 
#

package UsersPluginMailGroups;

use strict;

use ycp;
use YaST::YCP;
use YaPI;

our %TYPEINFO;

use PluginMail;
use Net::IMAP;
use Data::Dumper;
use YaPI::MailServer;

textdomain("MailServer");

##--------------------------------------
##--------------------- global imports

YaST::YCP::Import ("SCR");

##--------------------------------------
##--------------------- global variables

# error message, returned when some plugin function fails
my $error       = "";

my $pluginName = "UsersPluginMailGroups"; 


# All functions have 2 "any" parameters: this will probably mean
# 1st: configuration map (hash) - e.g. saying if we work with user or group
# 2nd: data map (hash) of user (group) to work with

# in 'config' map there is a info of this type:
# "what"        => "user" / "group"
# "modified"        => "added"/"edited"/"deleted"
# "enabled"        => 1/ key not present
# "disabled"        => 1/ key not present

# 'data' map contains the atrtributes of the user. It could also contain
# some keys, which Users module uses internaly (like 'groupname' for name of
# user's default group). Just ignore these values
    
##------------------------------------


# return names of provided functions
BEGIN { $TYPEINFO{Interface} = ["function", ["list", "string"], "any", "any"];}
sub Interface {

    my $self        = shift;
    my @interface   = (
        "Interface",
        "Error",
        "InternalAttributes",
        "Name",
        "Summary",
        "GUIClient",
        "Restriction",
        "PluginPresent",
        "Check",
        "Disable",
        "AddBefore",
        "Add",
        "WriteBefore",
        "Write",
        "EditBefore",
        "Edit"
    );
    return \@interface;
}

# return error message, generated by plugin
BEGIN { $TYPEINFO{Error} = ["function", "string", "any", "any"];}
sub Error {
    
    my $self            = shift;
    my $ret = $error;
    $error = "";
    return $ret;
}

# this will be called at the beggining of Users::Edit
BEGIN { $TYPEINFO{InternalAttributes} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub InternalAttributes {
    return [ "localdeliverytype"];
}

# return plugin name, used for GUI (translated)
BEGIN { $TYPEINFO{Name} = ["function", "string", "any", "any"];}
sub Name {

    my $self        = shift;
    # plugin name
    return __("Group Mail Attributes");
}

# return plugin summary
BEGIN { $TYPEINFO{Summary} = ["function", "string", "any", "any"];}
sub Summary {

    my $self    = shift;
    my $what    = "group";
    # summary
    my $ret     = __("Edit group mail parameters");

    return $ret;
}


# return name of YCP client defining YCP GUI
BEGIN { $TYPEINFO{GUIClient} = ["function", "string", "any", "any"];}
sub GUIClient {

    my $self    = shift;
    return "users_plugin_mail_groups";
}

##------------------------------------
# Type of users and groups this plugin is restricted to.
# If this function doesn't exist, plugin is applied for all user (group) types.
BEGIN { $TYPEINFO{Restriction} = ["function",
    ["map", "string", "any"], "any", "any"];}
sub Restriction {

    my $self    = shift;
    # this plugin applies only for LDAP groups
    return { "ldap"    => 1,
            "group"    => 1,
	    "user"     => 0
           };
}

# checks the current data map of user/group (2nd parameter) and returns
# true if given user (group) has our plugin
BEGIN { $TYPEINFO{PluginPresent} = ["function", "boolean", "any", "any"];}
sub PluginPresent {
    my $self    = shift;
    my $config  = shift;
    my $data    = shift;
    if ( grep /^suseMailRecipient$/i, @{$data->{'objectclass'}} ) {
        y2milestone( "MailPluginGroup: Plugin Present");
        return 1;
    } else {
        y2milestone( "MailPluginGroup: Plugin not Present");
        return 0;
    }
}

##------------------------------------
# check if all required atributes of LDAP entry are present
# parameter is (whole) map of entry (user/group)
# return error message
BEGIN { $TYPEINFO{Check} = ["function",
    "string",
    "any",
    "any"];
}
sub Check {

    my $self    = shift;
    my $config    = $_[0];
    my $data    = $_[1];
    
    # attribute conversion
    my @required_attrs        = ();
    my @object_classes        = ();
    if (defined $data->{"objectclass"} && ref ($data->{"objectclass"}) eq "ARRAY") {
        @object_classes        = @{$data->{"objectclass"}};
    }

    # get the attributes required for entry's object classes
    foreach my $class (@object_classes) {
        my $object_class = SCR->Read (".ldap.schema.oc", {"name"=> $class});
        if (!defined $object_class || ref ($object_class) ne "HASH" ||
            ! %{$object_class}) { next; }
        my $req = $object_class->{"must"};
        if (defined $req && ref ($req) eq "ARRAY") {
            foreach my $r (@{$req}) {
              push @required_attrs, $r;
            }
        }
    }

    # check the presence of required attributes
    foreach my $req (@required_attrs) {
        my $attr    = lc ($req);
        my $val        = $data->{$attr};
        if (!defined $val || $val eq "" || 
            (ref ($val) eq "ARRAY" && 
            ((@{$val} == 0) || (@{$val} == 1 && $val->[0] eq "")))) {
            # error popup (user forgot to fill in some attributes)
            return sprintf (__("The attribute '%s' is required for this object according".
            		   "to its LDAP configuration, but it is currently empty."), $attr);
        }
    }
    return "";
}

# this will be called at the beggining of Users::Edit
BEGIN { $TYPEINFO{Disable} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub Disable {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift;

    y2internal ("Disable Mail called");
    return $data;
}


# this will be called at the beggining of Users::Add
# Could be called multiple times for one user/group!
BEGIN { $TYPEINFO{AddBefore} = ["function",
    ["map", "string", "any"],
    "any", "any"];
}
sub AddBefore {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift; # only new data that will be copied to current user map

    $data    = update_object_classes ($config, $data);

    y2internal ("AddBefore Mail called");
    y2debug(Dumper($data));
    my $ldapret = get_LDAP_Config();

    if(@$ldapret <= 0) {
        $error = __("Run the mail server module first.");
        y2internal("You have to run the mail-server module, first.");
        return undef;
    }
    #print "AddBefore";
    #print Dumper($data);
    y2internal ("AddBefore Mail leaving");
    y2debug(Dumper($data));

    # looking for the local delivery type
    my $imapadmpw  = Ldap->bind_pass();
    my $MailLocalDelivery = YaPI::MailServer->ReadMailLocalDelivery($imapadmpw);
    $data->{'localdeliverytype'} = $MailLocalDelivery->{'Type'};
    if($data->{'localdeliverytype'} eq 'cyrus' ) {
        #setting default quota
        $data->{'imapquota'} =  $ldapret->[0]->{'suseimapdefaultquota'}->[0];
    } else {
        $error = __("Mailserver attributes for group are only avaiable if cyrus-IMAP is the local delivery system.");
        y2internal("Mailserver attributes for group are only avaiable if cyrus-IMAP is the local delivery system.");
        return undef;
    }

    return $data;
}

# This will be called just after Users::Add - the data map probably contains
# the values which we could use to create new ones
# Could be called multiple times for one user/group!
BEGIN { $TYPEINFO{Add} = ["function", ["map", "string", "any"], "any", "any"];}
sub Add {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift; # the whole map of current user/group after Users::Edit

    y2internal ("Add Mail called");
    y2debug(Dumper($data));
    return undef if !defined $data;
    return $data if !defined $data->{'cn'} || $data->{'cn'} eq "";
   
    if( grep /^UsersPluginMailGroups$/, @{$data->{'plugins_to_remove'}} ) {
        my @updated_oc;
        foreach my $oc ( @{$data->{'objectclass'}} ) {
            if ( lc($oc) ne "susemailrecipient" ) {
                push @updated_oc, $oc;
            }
        }
        delete( $data->{'imapquota'});
        delete( $data->{'imapquotaused'});

        $data->{'objectclass'} = \@updated_oc;
        y2debug ("Removed Mail plugin");
        y2debug ( Data::Dumper->Dump( [ $data ] ) );
        return $data;
    }

    return addRequiredMailData($data);
}

# this will be called at the beginning of Users::Edit
BEGIN { $TYPEINFO{EditBefore} = ["function", ["map", "string", "any"], "any", "any"]; }
sub EditBefore {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift; # only new data that will be copied to current user map
    # data of original user/group are saved as a submap of $config
    # data with key "org_data"
    
    y2internal ("EditBefore Mail called");
    y2debug( Dumper($data) );
    
    # Only change objectclasses if they are already present (sometimes EditBefore 
    # is called with an empty $data hash)
    if ( $data->{'objectclass'} ) {
        $data    = update_object_classes ($config, $data);
        
        my $ldapret = get_LDAP_Config();
        
        if(@$ldapret <= 0) {
            $error = __("Run the mail server module first.");
            return undef;
        }
    }
    
    # looking for the local delivery type
    my $imapadmpw  = Ldap->bind_pass();
    my $MailLocalDelivery = YaPI::MailServer->ReadMailLocalDelivery($imapadmpw);
    $data->{'localdeliverytype'} = $MailLocalDelivery->{'Type'};
    
    return $data;
}

# this will be called just after Users::Edit
BEGIN { $TYPEINFO{Edit} = ["function", ["map", "string", "any"], "any", "any"]; }
sub Edit {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift; # the whole map of current user/group after Users::Edit
    
    y2internal ("Edit Mail called");
    y2debug(Dumper($data));
    
    if ( ! $data->{'imapquota'} ) {
        my $tmp_data = cond_IMAP_OP($data, "getquota");
        if( $tmp_data ) {
            $data = $tmp_data;
        }
    }
    # Has the plugin been removed?
    if( grep /^UsersPluginMailGroups$/, @{$data->{'plugins_to_remove'}} ) {
        my @updated_oc;
        foreach my $oc ( @{$data->{'objectclass'}} ) {
            if ( lc($oc) ne "susemailrecipient" ) {
               push @updated_oc, $oc;
            }
        }
        delete( $data->{'imapquota'});
        delete( $data->{'imapquotaused'});
        
        $data->{'objectclass'} = \@updated_oc;
        
        y2milestone ("Removed Mail plugin");
        y2debug ( Data::Dumper->Dump( [ $data ] ) );
    } else {
      return addRequiredMailData($data);
    }
    
    return $data;
}


# what should be done before user is finally written to LDAP
BEGIN { $TYPEINFO{WriteBefore} = ["function", "boolean", "any", "any"];}
sub WriteBefore {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift;

    y2internal ("WriteBefore Mail called");
    y2debug( Dumper($data) );

    return if $data->{'cn'} eq "" || ! defined $data->{'cn'};

    # looking for the local delivery type
    my $imapadmpw  = Ldap->bind_pass();
    my $MailLocalDelivery = YaPI::MailServer->ReadMailLocalDelivery($imapadmpw);
    $data->{'localdeliverytype'} = $MailLocalDelivery->{'Type'};

    # this means what was done with a user/group: added/edited/deleted
    my $ldapret = get_LDAP_Config();

    if(@$ldapret <= 0) {
        $error = __("Run the mail server module first.");
        y2internal("You have to run the mail-server module, first.");
        return undef;
    }

    # is the user being deleted?
    if ( ($config->{'modified'} eq "deleted" ) && $self->PluginPresent($config, $data) ){
        cond_IMAP_OP($data, "delete") ;
        # ignore errors here otherwise it might be possible, that a user can't
        # be deleted at all
        $error = "";
        return 1;
    }
    # Has the plugin been removed?
    if ( grep /^UsersPluginMailGroups$/, @{$data->{'plugins_to_remove'}}) {
        cond_IMAP_OP($data, "delete");
        # ignore errors here otherwise it might be possible, that the plugin can't
        # be deleted for the user at all
        $error = "";
        return 1;
    }

    if ( ($config->{'modified'} eq "edited" ) && $self->PluginPresent($config, $data) ) {
        # create Folder if plugin has been added
        if ( ! grep /^suseMailRecipient$/i, @{$data->{'org_user'}->{'objectclass'}} ) {
            y2milestone("creating INBOX");
            cond_IMAP_OP($data, "add","group");
            return;
        } else {
            y2milestone("updating INBOX");
            cond_IMAP_OP($data, "update","group");
            return;
        }
    }
    
    return 1;
}

# what should be done after user is finally written to LDAP
BEGIN { $TYPEINFO{Write} = ["function", "boolean", "any", "any"];}
sub Write {

    my $self    = shift;
    my $config  = shift;
    my $data    = shift;

    # this means what was done with a user: added/edited/deleted
    my $action = $config->{"modified"} || "";
    y2internal ("Write Group Mail called");
    y2debug( Dumper($data) );
    if ( $config->{'modified'} eq "added" && $self->PluginPresent($config, $data) ) {
        # create Folder if plugin has been added
        cond_IMAP_OP($data, "add","group");
        return;
    }
    return 1;
}

##--------------------------------------
1
# EOF
